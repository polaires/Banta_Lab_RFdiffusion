#!/usr/bin/env python3
"""
End-to-end test of the metal binding pipeline mimicking frontend behavior.

Runs real API calls against the local Docker container (localhost:8000).
Tests each step: parse_intent → scaffold_search → configure → rfd3 (single) → mpnn → rf3

Usage:
    python test_metal_pipeline_e2e.py
"""

import json
import sys
import time
import requests

API_URL = "http://localhost:8000/runsync"
QUERY = "design a protein to bind terbium and citrate"

# Frontend ligand name → code mapping (from natural-language.ts line 524)
LIGAND_CODE_MAP = {
    "citrate": "CIT", "pqq": "PQQ", "atp": "ATP", "nad": "NAD", "heme": "HEM",
}


def call_api(task: str, payload: dict, label: str, timeout: int = 120) -> dict:
    """Call the backend API and return the result."""
    print(f"\n{'='*60}")
    print(f"STEP: {label}")
    print(f"  task: {task}")
    print(f"  payload keys: {list(payload.keys())}")

    start = time.time()
    try:
        resp = requests.post(
            API_URL,
            json={"input": {"task": task, **payload}},
            timeout=timeout,
        )
        elapsed = time.time() - start

        if resp.status_code != 200:
            print(f"  HTTP ERROR: {resp.status_code}")
            print(f"  Response: {resp.text[:500]}")
            return {"status": "failed", "error": f"HTTP {resp.status_code}"}

        data = resp.json()
        output = data.get("output", data)
        status = output.get("status", "unknown")

        print(f"  status: {status}")
        print(f"  elapsed: {elapsed:.1f}s")

        if status in ("failed", "FAILED"):
            error = output.get("error", data.get("error", "unknown"))
            print(f"  ERROR: {error}")
            return {"status": "failed", "error": error}

        result = output.get("result", output)

        # Print key fields (truncate large values)
        for k, v in result.items():
            if isinstance(v, str) and len(v) > 200:
                print(f"  {k}: <{len(v)} chars>")
            elif isinstance(v, list):
                print(f"  {k}: [{len(v)} items]")
                if len(v) > 0 and isinstance(v[0], dict):
                    print(f"    first item keys: {list(v[0].keys())}")
            elif isinstance(v, dict):
                print(f"  {k}: {json.dumps(v, indent=2)[:300]}")
            else:
                print(f"  {k}: {v}")

        return result

    except requests.Timeout:
        elapsed = time.time() - start
        print(f"  TIMEOUT after {elapsed:.1f}s")
        return {"status": "failed", "error": "timeout"}
    except Exception as e:
        print(f"  EXCEPTION: {e}")
        return {"status": "failed", "error": str(e)}


def main():
    print(f"Metal Binding Pipeline E2E Test")
    print(f"Query: {QUERY}")
    print(f"API: {API_URL}")

    # ---- Step 1: Parse Intent ----
    intent = call_api("ai_parse", {"query": QUERY}, "1. Parse Intent")

    if intent.get("status") == "failed":
        print("\n*** Parse intent failed, aborting ***")
        sys.exit(1)

    # Extract intent fields (mimic frontend)
    target_metal = intent.get("metal_type", "")
    ligand_name = intent.get("ligand_name", "")
    bury_ligand = intent.get("bury_ligand", True)
    source_pdb = intent.get("source_pdb_id", "")

    # Frontend maps ligand name to 3-letter code
    ligand_code = LIGAND_CODE_MAP.get(ligand_name.lower(), "") if ligand_name else ""

    print(f"\n  >> Parsed: metal={target_metal}, ligand_name={ligand_name}, "
          f"ligand_code={ligand_code}, bury={bury_ligand}")

    if not target_metal:
        print("\n*** No target metal detected, aborting ***")
        sys.exit(1)

    # ---- Step 2: Resolve Structure ----
    print(f"\n{'='*60}")
    print(f"STEP: 2. Resolve Structure")
    if source_pdb:
        print(f"  Would fetch PDB {source_pdb}")
    else:
        print(f"  No PDB — metal binding template generated by backend")
    pdb_content = None

    # ---- Step 3: Scaffold Search ----
    scaffold_result = call_api("scaffold_search", {
        "metal": target_metal,
        "ligand_name": ligand_name,  # Frontend passes ligand_name
    }, "3. Scaffold Search")

    scaffold_pdb = None
    if scaffold_result.get("status") != "failed" and scaffold_result.get("candidates"):
        candidates = scaffold_result["candidates"]
        best = candidates[0] if candidates else None
        if best:
            pdb_id = best.get("pdb_id", "")
            score = best.get("score", 0)
            print(f"\n  >> Best scaffold: {pdb_id} (score={score})")
            # In the frontend, if a scaffold is selected, its PDB is fetched
            # and passed as motif_pdb to RFD3. For now we skip this.
    else:
        print(f"\n  >> No scaffold found — backend will generate template")

    # ---- Step 4: Configure ----
    print(f"\n{'='*60}")
    print(f"STEP: 4. Configure Parameters")

    contig = "80-120"
    cfg_scale = 2.0
    num_designs = 2  # Small for testing
    num_timesteps = 200
    step_scale = 1.5

    config = {
        "target_metal": target_metal,
        "ligand_name": ligand_name,
        "ligand_code": ligand_code,
        "contig": contig,
        "cfg_scale": cfg_scale,
        "num_designs": num_designs,
        "bury_ligand": bury_ligand,
    }
    print(f"  {json.dumps(config, indent=2)}")

    # ---- Step 5: RFD3 Backbone Generation (metal single mode) ----
    rfd3_payload = {
        "mode": "single",
        "metal": target_metal,
        "ligand": ligand_code,  # Must be 3-letter code (CIT, not citrate)
        "contig": contig,
        "cfg_scale": cfg_scale,
        "num_designs": num_designs,
        "num_timesteps": num_timesteps,
        "step_scale": step_scale,
        "bury_ligand": bury_ligand,
        "seed": 42,
    }
    print(f"\n  RFD3 payload: {json.dumps(rfd3_payload, indent=2)}")

    rfd3_result = call_api(
        "metal_binding_design", rfd3_payload,
        "5. RFD3 Backbone Generation (metal single)", timeout=300,
    )

    designs = rfd3_result.get("designs", [])
    if not designs:
        print("\n*** No designs generated ***")
        print(f"  Result keys: {list(rfd3_result.keys())}")
        print(f"  Result: {json.dumps(rfd3_result, indent=2)[:1000]}")
        sys.exit(1)

    print(f"\n  >> Generated {len(designs)} backbone(s)")
    for i, d in enumerate(designs):
        content = d.get("content", "")
        atom_count = content.count("\nATOM")
        hetatm_count = content.count("\nHETATM")
        # Count residues
        residues = set()
        for line in content.split("\n"):
            if line.startswith("ATOM"):
                residues.add(line[22:26].strip())
        print(f"  Design {i+1}: {len(content)} chars, {atom_count} ATOM lines, "
              f"{hetatm_count} HETATM, {len(residues)} residues")

    # ---- Step 5.5: Scout Filter (SKIP for metal single) ----
    print(f"\n{'='*60}")
    print(f"STEP: 5.5 Scout Filter — SKIPPED (metal_single_mode)")
    print(f"  Passing {len(designs)} backbone PDBs through to MPNN")

    # ---- Step 6: MPNN Sequence Design ----
    all_sequences = []
    for i, d in enumerate(designs):
        pdb = d["content"]

        mpnn_result = call_api("mpnn", {
            "pdb_content": pdb,
            "temperature": 0.1,
            "num_sequences": 4,
            "model_type": "ligand_mpnn",
            # Metal-aware params (from getMetalMpnnConfig for hard Lewis acid)
            "ligand_mpnn_use_atom_context": 1,
            "pack_side_chains": True,
            "use_side_chain_context": True,
            "omit_AA": "C",
        }, f"6. MPNN Design {i+1}/{len(designs)}", timeout=120)

        if mpnn_result.get("status") == "failed":
            print(f"  >> MPNN FAILED for design {i+1}")
            continue

        # Find sequences in result — MPNN returns sequences in multiple formats:
        # 1. sequences: [{filename, content(FASTA)}] — content is multi-sequence FASTA
        # 2. sequences: [{sequence, score}] — individual sequences
        # 3. fasta_content: "FASTA string" — raw FASTA
        sequences = mpnn_result.get("sequences", [])
        packed = mpnn_result.get("packed_structures", [])
        fasta = mpnn_result.get("fasta_content", "")

        print(f"  >> Design {i+1}: sequences={len(sequences)} items, "
              f"packed_structures={len(packed)} items")

        # Parse sequences — handle {filename, content} format (FASTA in content field)
        parsed_seqs = []
        if sequences and isinstance(sequences, list):
            for seq_item in sequences:
                if isinstance(seq_item, dict):
                    # Check for FASTA content in 'content' field
                    content = seq_item.get("content", "") or seq_item.get("sequence", "")
                    if content and ">" in content:
                        # Parse multi-sequence FASTA
                        current_header = ""
                        current_seq = ""
                        for line in content.split("\n"):
                            line = line.strip()
                            if line.startswith(">"):
                                if current_header and current_seq:
                                    parsed_seqs.append({"sequence": current_seq, "header": current_header})
                                current_header = line[1:]
                                current_seq = ""
                            elif line:
                                current_seq += line
                        if current_header and current_seq:
                            parsed_seqs.append({"sequence": current_seq, "header": current_header})
                    elif content:
                        parsed_seqs.append({"sequence": content})
                elif isinstance(seq_item, str):
                    parsed_seqs.append({"sequence": seq_item})
        elif fasta:
            current_seq = ""
            for line in fasta.split("\n"):
                if line.startswith(">"):
                    if current_seq:
                        parsed_seqs.append({"sequence": current_seq})
                    current_seq = ""
                else:
                    current_seq += line.strip()
            if current_seq:
                parsed_seqs.append({"sequence": current_seq})

        if parsed_seqs:
            print(f"  >> Design {i+1}: {len(parsed_seqs)} sequences parsed")
            for j, s in enumerate(parsed_seqs[:3]):
                seq = s["sequence"][:60]
                print(f"     seq {j+1}: {seq}... ({len(s['sequence'])} aa)")
            all_sequences.extend([{**s, "backbone_idx": i} for s in parsed_seqs])
        else:
            print(f"  >> Design {i+1}: No sequences found!")
            print(f"     Result keys: {list(mpnn_result.keys())}")
            for k in mpnn_result:
                v = mpnn_result[k]
                if isinstance(v, str) and len(v) > 100:
                    print(f"     {k}: <{len(v)} chars>")
                else:
                    print(f"     {k}: {v}")

    if not all_sequences:
        print("\n*** No sequences generated — check MPNN output format ***")
        sys.exit(1)

    print(f"\n  >> Total sequences: {len(all_sequences)}")

    # ---- Step 7: RF3 Structure Validation ----
    print(f"\n{'='*60}")
    print(f"STEP: 7. RF3 Structure Validation")

    # Only validate first 2 sequences
    test_seqs = all_sequences[:2]
    validated = 0
    failed = 0

    for i, seq_data in enumerate(test_seqs):
        sequence = seq_data.get("sequence", "") if isinstance(seq_data, dict) else str(seq_data)
        if not sequence:
            continue

        rf3_result = call_api("rf3", {
            "sequence": sequence,
        }, f"7. RF3 Validate seq {i+1}/{len(test_seqs)}", timeout=180)

        if rf3_result.get("status") == "failed":
            failed += 1
            continue

        # RF3 returns: {predictions: [{content, confidences: {summary_confidences: {ptm, overall_plddt}}}]}
        predictions = rf3_result.get("predictions", [{}])
        pred = predictions[0] if predictions else rf3_result
        confidences = pred.get("confidences", rf3_result.get("confidences", {}))
        summary = confidences.get("summary_confidences", confidences) if isinstance(confidences, dict) else {}

        ptm = float(summary.get("ptm", pred.get("ptm", rf3_result.get("ptm", 0))))
        plddt = float(summary.get("overall_plddt", pred.get("mean_plddt", rf3_result.get("plddt", 0))))
        pdb_out = pred.get("content", pred.get("pdb_content", rf3_result.get("cif_content", "")))

        print(f"  >> Seq {i+1}: pTM={ptm:.3f}, pLDDT={plddt:.3f}, output={len(pdb_out) if pdb_out else 0} chars")
        if ptm > 0 or plddt > 0 or pdb_out:
            validated += 1
        else:
            # May have succeeded but with unexpected format
            print(f"     Result keys: {list(rf3_result.keys())}")
            if predictions:
                print(f"     Prediction keys: {list(pred.keys()) if isinstance(pred, dict) else 'N/A'}")
            failed += 1

    # ---- Summary ----
    print(f"\n{'='*60}")
    print(f"PIPELINE SUMMARY")
    print(f"{'='*60}")
    print(f"  Query:      {QUERY}")
    print(f"  Metal:      {target_metal}")
    print(f"  Ligand:     {ligand_name} ({ligand_code})")
    print(f"  Bury:       {bury_ligand}")
    print(f"  Backbones:  {len(designs)}")
    print(f"  Sequences:  {len(all_sequences)}")
    print(f"  RF3 pass:   {validated}/{len(test_seqs)}")
    print(f"  RF3 fail:   {failed}/{len(test_seqs)}")
    print(f"\nDone!")


if __name__ == "__main__":
    main()
